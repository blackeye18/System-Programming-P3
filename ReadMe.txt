Παναγιώτης Μαυρομμάτης - 1115201800115 - sdi1800115
3η εργασία SysPro 2021

Για την εκτέλεση:
Κάνουμε extract το αρχείο και τρέχουμε τις εξής εντολές:
make //Για να γίνει compile το πρόγραμμα, τα εκτελέσιμα βγαίνουν στον φάκελο build
cd build
./travelMonitorClient -m 10 -b 5 -c 10 -s 100000 -i input_dir -t 20 //Για να τρέξουμε το πρόγραμμα

Αρχεία ανα φάκελο:
Στο φάκελο build περιέχεται 1 έτοιμο input_dir.
Επιπλέον τα εκτελέσιμα του βασικού προγράμματος βγαίνουν σε αυτόν τον φάκελο.
Στον φάκελο examples περιέχεται το αρχείο main.c, που περιέχει την main συνάρτηση για το travelMonitorClient, και το main2.c που περιέχει την main συνάρτηση για το monitorServer.

Στον φάκελο src περιέχονται 11 .c αρχεία που περιέχουν συναρτήσεις που χρειάζεται το καθε πρόγραμμα. Πιο συγκεκριμένα στο αρχείο
bloomFunctions.c περιέχεται ο κώδικας που μας δόθηκε στο piazza για το functions χρησιμοποιείται και απο τα 2 προγραμμάτα.
Στο αρχείο bloomfilter.c περιέχονται οι συναρτήσεις απο την πρώτη εργασία για το bloom filter. Το χρησιμοποιεί μόνο το monitorServer. 
Αντίστοιχα στο skipListFunctions.c περιέχονται οι συναρτήσεις που χρειάζονται για την δημιουργία των skip lists, τις οποίες χρησιμοποιεί μόνο το monitorServer.
Στο αρχείο monitor_main_questions.c βρίσκονται οι συναρτήσεις που μας ζητείτε να 
υλοποιησουμε απο την εκφώνηση για το κομμάτι του monitorServer. Όμοια, στο αρχείο travel_main_questions.c βρίσκονται οι συναρτήσεις που μας ζητείτε να 
υλοποιησουμε απο την εκφώνηση για το κομμάτι του travelMonitorClient. Στο BST.c βρίσκονται βοηθητικές συναρτήσεις για τα binary search trees που έχω υλοποιήσει για τους ιούς
και τις χώρες, το οποίο χρησιμοποιείται απο το monitorServer. Στο αρχείο StartersAndHelpFunctions.c περιέχονται οι πιο βασικές συναρτήσεις του προγράμματος monitorServer, όπως το αρχικό διάβασμα
από τα αρχεία, το διάβασμα των εντολών που δίνει ο χρήστης, την δημιουργία των προαναφερόμενων δυαδικών δένδρων και την δημιουργία
της βασικής single linked list. Και αυτό χρησιμοποιείται μόνο απο το monitorServer.Στο Functions_travelmonitor.c βρίσκονται βοηθητικές συναρτήσεις για τα binary search trees που έχω υλοποιήσει για τους ιούς
και τις χώρες, το οποίο χρησιμοποιείται απο το monitorServer. Στο αρχείο monitornewfunc.c περιέχονται οι βοηθητικές συναρτήσεις του monitor που αφορούσαν τα namedpipes και πλεον τα sockets.
Στο αρχείο newfunctions_travelmonitor.c περιέχονται περιέχονται οι βοηθητικές συναρτήσεις του travelMonitorClient που αφορούσαν τα namedpipes, δηλαδή πλέον τα sockets, αλλά και το διάβασμα των bloomfilter από το monitor.
Τέλος, στο αρχείο ThreadFunctions.c περιέχονται οι συναρτήσεις του cyclicBuffer καθώς και οι συναρτήσεις των threads.

Στον φάκελο include περιέχονται τα αντίστοιχα headerFiles των .c αρχείων που αναφέρω παραπάνω. Επίσης περιέχεται και το structs.h, το οποίο περιέχει
defines για το μέγιστο και ελάχιστο βάθος της SkipList, για το μέγιστο μήκος γραμμής, για το πλήθος των hash functions για το bloom filterκαθώς και 
τις δηλώσεις των structs που χρησιμοποιούνται στο monitorServer, όπως το sturct του cyclicBuffer και το struct των arguments για τα threads. 
Αντίστοιχα υπάρχει το structs_travel.h για το travelMonitor.

Ζητάω συγγνώμη αν σε κάποια σημεία μου έχουν ξεφύγει comments στα αγγλικά, απλώς στην πρώτη εργασία είχα ξεκινήσει να γράφω στα αγγλικά αλλά στην πορεία το μετάνιωσα.....

Στο ReadMe εξηγώ κυρίως την λογική και τον τρόπο λειτουργίας των προγραμμάτων μου, ενώ στα σχόλια εξηγώ ακριβώς τι κάνω.
Για οποιαδήποτε τυχών απορία στο πρόγραμμα μου, παρακαλώ να ανατρέξετε στα σχόλια που υπάρχουν για κάθε συνάρτηση.

Σημείωση: Στην επιλύση μου, καθώς είχαμε το ελεύθερο από τους καθηγητές, επέλεξα να θεωρήσω ως server για τα sockets τον travelMonitorClient και ως clients τα MonitorServers. Η επιλογή αυτή έγινε καθώς,
κατά την γνώμη μου, πιο λογική προσέγγιση για το πρόβλημα που έχουμε είναι να υπάρχει ένας server και πολλοί clients, παρά πολλοί server και ένα client. Το μόνο που αλλάζει με την αλλαγή αυτή είναι το ποια εφαρμογή,
κάνει connect και ποια κάνει listen και accept για τα sockets.

Επιπλέον, επείδη και σε αυτήν την περίπτωση είχαμε το ελεύθερο από τους καθηγητές, επέλεξα τα threads του monitorServer να τερματίζουν με το που τελειώσουν και να μην περιμένουν ενεργά μέχρι τον τερματισμό του προγράμματος.
Η επιλογή αυτή έγινε για εξοικονόμηση μνήμης, αφού σε ακραίες περιπτώσεις θα μπορούσαμε να έχουμε 100+ threads φορτωμένα στην μνήμη χωρίς να κάνουν τίποτα, αλλά επίσης επειδή υπάρχει περίπτωση να μην ξαναχρησιμοποιηθούν. Αφού αν δεν 
γίνει κάποιο αίτημα /addVaccinationRecords, τότε τα threads δεν θα ξαναχρησιμοποιηθούν.

Σχετικά με την κύρια εφαρμογή:
Το bufferSize λειτουργεί σίγουρα για όλες τις αποδεκτές τιμές για >2 bytes. Πιστευώ ότι το πρόγραμμα μου λογικά λειτουργεί και για >1 bytes, απλώς δεν είχα τον απαραίτητο χρόνο να το δοκιμάσω.
Το cyclicBuffer έχει δοκιμαστεί και λειτουργεία ακόμα και για μέγεθος =1.
Ξεκινώντας από την main, γίνεται έλεγχος για το πλήθος των ορισμάτων. Στην συνέχεια διαβάζονται τα περιέχομετα του inputDir και με την μέθοδο round robin χωρίζονται οι χώρες στα monitors. Δημιουργούνται τα sockets, γίνεται numMonitors φορές
fork και τα παιδία εκτελούν την monitorServer με τα αντίστοιχα ορίσματα. 
Στο monitorServer γίνεται πάλι έλεγχος για το πλήθος των ορισμάτων και ξεχωρίζει τις χώρες που έχει αναλάβει. Έπειτα δημιουργείται το κυκλικό buffer, γίνοντε initialised τα mutexes, δημιουργείται το struct που θα πάρουν τα threads ως argument,
και τέλος δημιουργούνται και εκτελούντε τα threads με την αντίστοιχη thread συνάρτηση. Στην συνάρτηση αυτή, με την βοήθεια των συναρτήσεων από την πρώτη εργασία τα monitorServer διαβάζουν, όσο πιο παράλληλα γίνεται, τα 
αντίστοιχα τα αρχεία τους, γεμίζοντας λίστες headCitizen και τα δυαδικά δέντρα. Γίνονται join τα threads, και οι πολλές μικρές λίστες headCitizen, γίνεται συγκεντρωτικά μία μεγάλη.
Στη συνέχεια, όπως και στην πρώτη εργασία, δημιουργείται το bloom filter και οι skiplists. Επιπλέον τα monitorServer ενημερώνουν το travelmonitor για το πλήθος και  τα ονόματα των ιών που έχουν, έτσι ώστε το travelmonitor να φτιάξει μια συνολική δικιά του βάση.
Έπειτα τα monitors στέλνουν τα bloom filter τους και το travelmonitor τα διαβάζει. Ακολουθεί η κύρια λούπα του προγραμμάτος, όπου ο χρήστης δίνει εντολές. Τέλος, όταν ο χρήστης γράψει /exit, το travel monitor δημιουργεί το logfile του, ενημέρωνει τα monitors ότι τελειώνει. 
Τα numMonitors  δημιουργούν και αυτα logfiles. Στην συνέχει ο TravelMonitorServer περιμένει τους MonitorServer να ελευθερώσουν την μνήμη και να τερματίσουν. Μόλις γίνει αυτό, ο TravelMonitorServer ελευθερώνει και αυτός την μνήμη του και 
τερματίζει.


Θεωρώ ότι έχει υλοποιηθεί στο πρόγραμμά μου είναι πλήρες, με εξαίρεση ίσως κάποια ελάχιστα memory leaks (<100 bytes) που προκύπτουν από τις strdup στην συνάρτηση insert_new_citizen_record, από την πρώτη εργασία. 
Η μετατροπή της addVaccinationRecords απο απλή συνάρτηση σε συνάρτηση που να λειτουργεί με threads έγινε μόνο με ένα mutex. Ο λόγος υλοποιήθηκε έτσι είναι διότι, στην συγκεκριμένη περίπτωση, η υλοποίησή μου για να καταφέρει να γίνει περισσότερα mutexes, όπως έγινε το διάβασμα
των αρχείων, θα χρειαζόταν τόσες πολλές αλλαγές που θα ήταν προτιμότερο να την ξαναέγραφα από την αρχή. Όπως καταλαβαίνετε, δεν υπήρχε το ανάλογο περιθώριο χρόνου για να ξαναγραφτεί μια τόσο μεγάλη συνάρτηση από την αρχή.
